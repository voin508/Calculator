# Билет №14. Поиск подстроки. Алгоритм Кнута – Морриса – Пратта.

**Определение:** Алгоритм определяет, начиная с какого символа подстрока будет содержаться в строке. Если подстрока не содержится, то возвращается -1 (или любое др. значение, которое нельзя воспринимать как индекс).  

## Основные термины и обозначения
- **Строка** - набор символов, среди которых производится поиск.  
- **Подстрока** - непустая часть строки, которую необходимо найти в строке.  
- **Префикс** - символы, стоящие в начале образа  
- **Суффикс** - символы, стоящие в конце образа  
- *Примечание* - рассматриваются префиксы и суффиксы всех длин, кроме длины самой строки (до n-1).
- **Алгоритм Кнута – Морриса – Пратта** - Алгоритм поиска подстроки в строке.



## Псевдокод
```python
Приведём здесь итоговую схему алгоритма:

Считать значения префикс-функции π[q] будем по очереди: от q=2 к i=m   
(значение π[1] просто присвоим равным нулю).Для подсчёта текущего значения π[q]  
мы заводим переменную k, обозначающую длину текущего рассматриваемого образца.  
Изначально k = 0. Тестируем образец длины k, для чего сравниваем символы P[k+1] и P[q].  
Если они совпадают — то k++ и переходим к следующему индексу q+1.  
Если же символы отличаются, то уменьшаем длину k, полагая её равной P[k], и повторяем  
этот шаг алгоритма с начала. Если мы дошли до длины k=0 и так и не нашли совпадения,  
то останавливаем процесс перебора образцов и полагаем π[q] = 0 и переходим к следующему индексу q+1.  

prefixFunction(P):
  π[1] = 0
  k = 0
  for q = 2 to m do
      while (k > 0) and (P[k+1] != P[q]) do
          k = π[k]
      if P[k+1] == P[q] then
          k++
      π[q] = k
  return π
  
 Основная функция: 
m - длина строки
n - длина подстроки
T - строка
P - подстрока

KMP (T,P)
  π = prefixFunction (P)
  q = 0
  for i = 1 to n do
    while (q > 0) and (P[q + 1] ≠ T[i]) do
      q = π[q]
    if P[q + 1] = T[i] then
      q = q + 1
    if q = m then
      print “Подстрока входит со сдвигом” i – m
    q = π[q]
```

## Пример 

- Пример составления префикс-функции для строки abcabd.  
*Грубо говоря, мы просто берем сначала 1 символ спереди и 1 символ сзади, сравниваем их, далее 2 символа спереди и 2 символа сзади и т.д. и делаем это для подстрок всех длин начиная с 2 и до конца.*

![](https://github.com/PetrSU-IMIT-2020/algo/blob/main/question14/images/1.png)

- Далее имея готовую префикс-функцию, можно начинать искать подстроку в строке. Как видно на примере, не совпали строки на 5 символе, в таком случае надо обратиться к хэш-функции подстроки и посмотреть, что было на предыдущей позиции (на 4ой).  

![](https://github.com/PetrSU-IMIT-2020/algo/blob/main/question14/images/2.png)

- Очевидно, что это число 2, а значит мы берем 2ой элемент массива (отсчет начинается с нуля) и ставим на ту позицию, где произошло несовпадение.  


![](https://github.com/PetrSU-IMIT-2020/algo/blob/main/question14/images/3.png)

 - И так далее, пока не найдем полное совпадение. Если слово совпало, то возвращаем индекс, начиная с которого оно совпадает. Ответ 9.

![](https://github.com/PetrSU-IMIT-2020/algo/blob/main/question14/images/4.png)

- *Примечание: если не совпал первый элемент, то мы просто сдвигаем на 1 элемент вправо.*


## Временная сложность

- Работает за время:  
$O(n + m)$,    
где n - длина строки, m - длина подстроки

## Создатель

Автор расписанного билета: Топчий Евгений и Смирнов Константин

Кто проверил: 

## Ресурсы
- Видос на ютубе (https://www.youtube.com/watch?v=Cbt67mfrF6o) 
- Хабр (https://habr.com/ru/post/307220/?)
