# Билет №15. Поиск подстроки. Алгоритм Бойера – Мура.

**Определение:** Алгоритм поиска подстроки в строке.  

## Основные термины и обозначения
- **Строка** - набор символов, среди которых производится поиск.  
- **Подстрока(образ)** - непустая часть строки, которую необходимо найти в строке.
- **Алгоритм Бойера – Мура** - Алгоритм поиска подстроки в строке.

## Алгоритм
- Этап 1 - Составление таблицы  
ШАГ 1: Составление таблицы - значение элемента таблицы равно удаленности соответствующего символа от конца образа.  
ШАГ 2: Если символ встречается более одного раза, то применяется значение, соответствующее символу, наиболее близкому к концу образа.  
ШАГ 3: Если символ в конце образа встречается 1 раз, ему соответствует значение, равное длине образа: если более 1 раза - применяем значение, соответствующее символу, наиболее близкому к концу образа.  
ШАГ 4: Для символов, отсутствующих в образе, применяется значение, равное длине образа.  

- Этап 2 - Алгоритм поиска  
ШАГ 1: При сравнение строки и образа, в случае несовпадения символов, образ сдвигается вдоль строки слева направо.  
ШАГ 2: По самому образу проходим справо налево  
ШАГ 3: При несовпадении символов смещение определяется значением таблицы, соответствующим символу строки. Если уже был ряд совпадений символов строки и образа и произошло несовпадение, то смещение определяется значением таблицы, соответствующим последнему символу образа.  

## Псевдокод

```python
Мы не понимаем, что это за говно, как тут юзаются 2 таблицы, как они вообще составляются. Если кто-то адекватно
распишет - будет кайфово.
```

## Пример 
Для работы алгоритма Боера-Мура необходимо заполнить таблицу. Каждому символу образа будет соответствовать
значение его удаленности от конца образа. Заполнять таблицу начинаем с предпоследнего символа. Если символ
уже был в образе(в данном случае буква "н"), то ему присваивается значение, которое находится наиболее близко к концу
образа. Последнему символу присваивается длина образа, как и звездочке.
Во втором случае, если последний символ уже встречался в образе, ему присваивается значение, максимально близкое
к концу образа, в нашем случае 4.
![](https://github.com/PetrSU-IMIT-2020/algo/blob/main/question15/images/1.png)

Начинаем двигать образ слева направо, сравнивая образ и часть строки с последнего символа.
Символы "Н" и "Е" не совпадают, смотрим в таблицу, видим, что у "Н" значение "2", то есть
мы сдвигаем наш орбраз на 2 символа.
![](https://github.com/PetrSU-IMIT-2020/algo/blob/main/question15/images/2.png)

Снова проверяем, начиная с последнего символа. Символы "Л" и "Е" не совпадают,
смотрим в таблицу. Значения "Л" в таблице нет, поэтому берем значение "\*",
которое равно "6", и сдвигаем наш образ на 6 символов.
![](https://github.com/PetrSU-IMIT-2020/algo/blob/main/question15/images/3.png)

Снова проверяем, начиная с последнего символа. Символ "Д" и "Е" не совпадают,
смотрим в таблицу. Значение "Д" равно "5". Сдвигаем наш образ на 5 символов.
![](https://github.com/PetrSU-IMIT-2020/algo/blob/main/question15/images/4.png)

Снова проверяем, начиная с последнего символа. Все символы совпали, образ найден.
![](https://github.com/PetrSU-IMIT-2020/algo/blob/main/question15/images/5.png)

## Временная сложность

Сложность: в худшем случае O(nm + |Σ|), на практике – самый эффективный
алгоритм.
Где:
- n - длина строки
- m - длина образца 
- Σ - конечный входной алфавит (|Σ| - мощность алфавита)
## Создатель

Автор расписанного билета: Топчий Евгений и Смирнов Константин

Кто проверил: 

## Ресурсы
- Видос на ютубе (https://www.youtube.com/watch?v=-lQzG0BmH1A)

