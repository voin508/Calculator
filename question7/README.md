# Билет №7. Кратчайшие пути в графе. Алгоритм Флойда.

## Основные термины и обозначения

- **Граф** $G = (V, E)$ – это совокупность двух множеств: множества вершин $V$ и множества ребер 
$E$, состоящего из неупорядоченных пар различных элементов множества $V$: 
$E ⊂ \lbrace ( u, v ) | u, v ∈ V \rbrace $;
- $D[v]$ – оценка веса кратчайшего пути из вершины $s$ в вершину v (D[v] ≥ δ(s, v))
- $\pi[v]$ – вершина, предшествующая вершине $v$ в пути из $s$.
- $D$ – матрица оценок весов кратчайших путей,
- $P$ – матрица путей


## Введение в билет

Пусть дан граф $G = (V, E)$ с вещественной весовой функцией $d$ : $E \rightarrow R$.
Весом пути $p = \lbrace v_0, v_1, \cdots , v_k \rbrace $ называется сумма весов дуг, входящих в этот путь: $\displaystyle d(p) = \sum_{i = 1}^{k}d(v_{i-1}, v_i)$
 
Вес кратчайшего пути из вершины u в вершину v:

$$ δ(u, v) = 
\begin{cases}
  min  \lbrace d(p): u\stackrel{p}{\leadsto} v \rbrace, \text{ если существует путь } p,\\      
  \infty \text{ иначе}
\end{cases}
$$

Кратчайший путь из $u$ в $v$ – это любой путь $p$ из $u$ в $v$, для которого $d(p) = δ(u, v)$.

## Алгоритм

Основная особенность данного алгоритма: **не должно быть контуров (циклов) с отрицательным весом**.

Для хранения дерева кратчайших путей будем для каждой вершины v запоминать ее родителя $\pi[v]$ в дереве.  
Будем искать кратчайшие пути из вершины s во все вершины графа.  
В конце работы алгоритмов для всех вершин $v$, достижимых из вершины $s$, будет выполнено $D[v] = δ(s, v)$.

Пусть, если $(u, v) \notin E$, то $d[u, v] = \infty$.

```python
for u=1 to m do           # Проходим по всем первым вершинам в ребрах
    for v = 1 to m do     # Проходим по всем вторым вершинам в ребрах
        D[u, v] = d[u, v] # Ставим оценку веса кратчайшего пути = длина ребра
        P[u, v] = 0       # Пишем, что кратчайший путь от u до v через нулевую вершину

for u=1 to m do # Идём по всем вершинам
    D[u, u] = 0 # Ставим расстояние от вершины до самой себя в ноль
    
for k=1 to m do           # Проходим по всем вершинам (промежуточная вершина)
    for u=1 to m do       # Проходим по всем первым вершинам в ребрах
        for v = 1 to m do # Проходим по всем вторым вершинам в ребрах
            
            # Если кратчайшее расстояние между u и v на данный момент больше, чем кратчайшее расстояние от u до k + кратчайшее расстояние от k до v 
            if D[u, v] > D[u, k] + D[k, v] then
                D[u, v] = D[u, k] + D[k, v] # Присваиваем сумму 
                P[u, v] = k                 # Пишем, что от u до v кратчайший путь через k
```

Алгоритм печати кратчайшего пути из вершины u в вершину v 

```python
path(u, v) # Принимает на вход откуда кратчйший путь и куда
    
    w = P[u, v] # Берём промежуточную вершину для кратчайшего пути
    
    # Если промежуточная вершина - корень, то выходим
    if w = 0 then 
        return

    path(u, w) # Ищем кратчайший путь от u до w
    print w    # Выводим промежуточную вершину
    path(w, v) # Ищем кратчайший путь от w до v
```

## Доказательство корректности работы алгоритма
TODO

## Пример
TODO

## Математическая модель (реккурентное соотношение)

Алгоритм Флойда основан на методе **динамического программирования**. После k-ой итерации D[u, v] содержит вес кратчайшего пути из $u$ в $v$, который не проходит через вершины с номерами, большими k.

Рекуррентное соотношение:
$$D_k [u, v] = min \lbrace D_{k−1}[u, v], D_k [u, k] + D_k [k, v]\rbrace$$

## Временная сложность
Время работы алгоритма $O(m^3)$, так как проходимся по всем вершинам в трёх вложенных циклах for от 1 до m.

Для разреженных графов выгоднее запустить m раз алгоритм Дейкстры, применив его для каждой вершины графа. В этом случае время работы составит $O(m^2 \log m)$.

---
## Создатель

Автор расписанного билета: Татьяна Квист

Кто проверил: 
- ...

## Ресурсы
